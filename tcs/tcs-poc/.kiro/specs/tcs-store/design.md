# Design Document: TCS Store

## Overview

The TCS Store is a FastAPI-based microservice that provides RESTful endpoints for managing trade data in memory. The service is designed with a layered architecture separating API routes, business logic, storage, and data models. It uses Pydantic for request/response validation and provides comprehensive CRUD operations with filtering capabilities.

The design prioritizes simplicity for the initial in-memory implementation while maintaining extensibility for future database integration. All trade data is stored in a thread-safe in-memory dictionary, with operations exposed through well-defined REST endpoints.

## Architecture

The application follows a three-layer architecture:

1. **API Layer** (`api/`): FastAPI route handlers that define endpoints and handle HTTP concerns
2. **Service Layer** (`services/`): Business logic for trade operations, validation, and filtering
3. **Storage Layer** (`storage/`): In-memory data store with thread-safe access

```
┌─────────────────────────────────────┐
│         FastAPI Application         │
├─────────────────────────────────────┤
│          API Routes Layer           │
│  /save, /load, /list, /delete       │
├─────────────────────────────────────┤
│         Service Layer               │
│  TradeService (business logic)      │
├─────────────────────────────────────┤
│         Storage Layer               │
│  InMemoryStore (thread-safe dict)   │
└─────────────────────────────────────┘
```

## Components and Interfaces

### 1. Data Models (`models/trade.py`)

**Context Model**
```python
class Context(BaseModel):
    user: str  # User ID or service account making the request
    agent: str  # Application or service identifier
    action: str  # Operation being performed (e.g., "save_new", "update", "delete")
    intent: str  # Business reason or workflow step
```

**Trade Model**
```python
class Trade(BaseModel):
    id: str  # UUID generated by calling API (32 chars)
    data: Dict[str, Any]  # Flexible JSON payload - no validation
    
    class Config:
        extra = "allow"  # Allow any additional fields
```

**TradeListItem Model**
```python
class TradeListItem(BaseModel):
    id: str
    # Additional fields extracted from data for display
    # Structure determined by client needs
    
    class Config:
        extra = "allow"
```

**Filter Model**
```python
class TradeFilter(BaseModel):
    # Structured common filters
    id: Optional[str] = None
    ids: Optional[List[str]] = None
    
    # Flexible JSON filter for any field
    # Supports operators: eq, ne, gt, gte, lt, lte, regex, in, nin
    # Example: {"data.trade_type": {"eq": "IR_SWAP"}}
    # Example: {"data.trade_date": {"gte": "2024-01-01", "lte": "2024-12-31"}}
    # Example: {"data.counterparty": {"regex": "^BANK.*"}}
    filter: Optional[Dict[str, Any]] = None
    
    # Pagination (for future use)
    limit: Optional[int] = None
    offset: Optional[int] = None
    
    class Config:
        extra = "allow"
```

**Request/Response Models**
```python
class SaveNewRequest(BaseModel):
    context: Context  # Required context metadata
    trade: Dict[str, Any]  # Must include 'id' field (UUID)

class SaveUpdateRequest(BaseModel):
    context: Context  # Required context metadata
    trade: Dict[str, Any]  # Must include 'id' field

class PartialUpdateRequest(BaseModel):
    context: Context  # Required context metadata
    id: str
    updates: Dict[str, Any]  # Partial trade data with deep merge

class LoadGroupRequest(BaseModel):
    ids: List[str]  # No context required for read operations

class LoadGroupResponse(BaseModel):
    trades: List[Dict[str, Any]]
    missing_ids: List[str]

class LoadFilterRequest(BaseModel):
    filter: TradeFilter  # No context required for read operations

class ListRequest(BaseModel):
    filter: TradeFilter  # No context required for read operations

class CountRequest(BaseModel):
    filter: TradeFilter  # No context required for read operations

class DeleteGroupRequest(BaseModel):
    context: Context  # Required context metadata
    ids: List[str]

class DeleteGroupResponse(BaseModel):
    deleted_count: int
    missing_ids: List[str]

class CountResponse(BaseModel):
    count: int

class ErrorResponse(BaseModel):
    error: str
    detail: Optional[str] = None

class HealthResponse(BaseModel):
    status: str
    version: str
```

### 2. Storage Layer (`storage/in_memory_store.py`)

**InMemoryStore Class**

The storage layer uses a simple dictionary with threading locks for thread safety. It also stores context metadata for each operation to enable lifecycle tracing.

```python
class OperationLog(TypedDict):
    timestamp: datetime
    context: Dict[str, str]  # user, agent, action, intent
    operation: str  # "save", "update", "delete", etc.
    trade_id: str
    
class InMemoryStore:
    def __init__(self):
        self._store: Dict[str, Dict[str, Any]] = {}
        self._operation_log: List[OperationLog] = []
        self._lock = threading.RLock()
    
    def save(self, trade_id: str, trade_data: Dict[str, Any], context: Dict[str, str]) -> None
    def get(self, trade_id: str) -> Optional[Dict[str, Any]]
    def exists(self, trade_id: str) -> bool
    def delete(self, trade_id: str, context: Dict[str, str]) -> bool
    def get_all(self) -> List[Dict[str, Any]]
    def clear(self) -> None
    def get_operation_log(self) -> List[OperationLog]
```

**Thread Safety**: All operations acquire the reentrant lock (`RLock`) to ensure thread-safe concurrent access.

**Lifecycle Tracing**: Each mutating operation (save, update, delete) logs the context metadata with a timestamp for audit trails.

### 3. Service Layer (`services/trade_service.py`)

**TradeService Class**

The service layer implements business logic and coordinates between the API and storage layers. It validates context metadata and passes it to the storage layer for lifecycle tracing.

```python
class TradeService:
    def __init__(self, store: InMemoryStore):
        self._store = store
    
    def save_new(self, trade: Dict[str, Any], context: Context) -> Dict[str, Any]
    def save_update(self, trade: Dict[str, Any], context: Context) -> Dict[str, Any]
    def save_partial(self, trade_id: str, updates: Dict[str, Any], context: Context) -> Dict[str, Any]
    def load_by_id(self, trade_id: str) -> Dict[str, Any]
    def load_by_ids(self, trade_ids: List[str]) -> Tuple[List[Dict[str, Any]], List[str]]
    def load_by_filter(self, filter: TradeFilter) -> List[Dict[str, Any]]
    def list_by_filter(self, filter: TradeFilter) -> List[Dict[str, Any]]
    def count_by_filter(self, filter: TradeFilter) -> int
    def delete_by_id(self, trade_id: str, context: Context) -> None
    def delete_by_ids(self, trade_ids: List[str], context: Context) -> Tuple[int, List[str]]
    
    def _apply_filter(self, trade: Dict[str, Any], filter: TradeFilter) -> bool
    def _deep_merge(self, existing: Dict[str, Any], updates: Dict[str, Any]) -> Dict[str, Any]
    def _validate_context(self, context: Context) -> None
```

**Context Validation**:
- Save and delete methods require a `Context` object
- Read methods (load, list, count) do NOT require context
- The `_validate_context()` method ensures all required fields (user, agent, action, intent) are present and non-empty for mutating operations
- Missing or invalid context raises a validation error

**Context Logging**:
- Context metadata is passed to storage layer for all mutating operations (save, delete)
- Context is logged with timestamp for lifecycle tracing
- Read operations do not log context as they don't modify data

**Trade ID Management**: 
- Trade IDs are UUIDs (32 characters) generated by the calling API
- The TCS Store validates that the `id` field is present but does not generate it
- Matching is based solely on the `id` field

**Partial Update Deep Merge Logic**: 
The `_deep_merge` method implements smart null handling:
- If existing value is a **dict/object** and update sets it to `null` → **Remove the field**
- If existing value is a **primitive** (string, number, bool, null) and update sets it to `null` → **Set to null**
- Nested dicts are merged recursively
- Lists are replaced entirely (not merged)

Example:
```python
existing = {"data": {"leg1": {...}, "broker": "BrokerA"}}
updates = {"data": {"leg1": null, "broker": null}}
result = {"data": {"broker": null}}  # leg1 removed, broker set to null
```

**Filtering Logic**: 
The filter supports:
- **Structured filters**: Direct field matching (e.g., `id`, `ids`)
- **Flexible JSON filters**: Nested field queries with operators
  - `eq`: Equals
  - `ne`: Not equals
  - `gt`, `gte`, `lt`, `lte`: Comparison operators
  - `regex`: Regular expression matching (Python `re` module, Postgres SIMILAR TO compatible)
  - `in`: Value in list
  - `nin`: Value not in list

Filter examples:
```python
# Simple equality
{"filter": {"data.trade_type": {"eq": "IR_SWAP"}}}

# Range query
{"filter": {"data.trade_date": {"gte": "2024-01-01", "lte": "2024-12-31"}}}

# Regex
{"filter": {"data.counterparty": {"regex": "^BANK.*"}}}

# Multiple conditions (AND logic)
{"filter": {
    "data.trade_type": {"eq": "IR_SWAP"},
    "data.notional": {"gte": 1000000}
}}
```

### 4. API Layer (`api/`)

**Route Modules**:
- `api/save.py`: Save endpoints (/save/new, /save/update, /save/partial)
- `api/load.py`: Load endpoints (/load/id, /load/group, /load/filter)
- `api/list.py`: List endpoints (/list, /list/count)
- `api/delete.py`: Delete endpoints (/delete/id, /delete/group)
- `api/health.py`: Health check endpoint (/health)

**Dependency Injection**: The `TradeService` instance is injected into route handlers using FastAPI's dependency injection system.

**Error Handling**: Custom exception handlers for:
- `TradeNotFoundError` → 404
- `TradeAlreadyExistsError` → 409
- `ValidationError` → 422
- Generic exceptions → 500

**HTTP Methods**: All endpoints use POST for consistency and to support complex request bodies (filters, bulk operations).

**Idempotency**:
- **DELETE operations**: Idempotent - deleting a non-existent trade returns success (200)
- **UPDATE operations**: NOT idempotent - updating a non-existent trade returns 404 error
- **SAVE operations**: NOT idempotent - saving an existing trade returns 409 error

This preserves user intent - updates and saves require the expected state to exist.

## Data Models

### Trade Data Structure

The `Trade` model is completely flexible - it accepts any JSON structure. The only requirement is the presence of an `id` field containing a UUID (32 characters) generated by the calling API.

**Minimal Trade**:
```json
{
  "id": "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6",
  "data": {
    "trade_type": "IR_SWAP",
    "counterparty": "BANK_A",
    "notional": 1000000
  }
}
```

**No Validation**: The TCS Store does not validate trade structure, field types, or required fields beyond the `id`. Validation will be handled by:
- The calling API (for business rules)
- Redis/PostgreSQL (for storage constraints)

### Filter Structure

Filters combine structured fields with flexible JSON queries:

**Structured Fields**:
- `id`: Single trade ID
- `ids`: List of trade IDs
- `limit`, `offset`: Pagination (future use)

**Flexible Filter**:
- `filter`: JSON object with nested field paths and operators
- Supports deep nesting (e.g., `data.leg1.schedule.start_date`)
- Operators: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`, `regex`, `in`, `nin`
- Multiple conditions use AND logic

**Filter Examples**:
```json
{
  "filter": {
    "data.trade_type": {"eq": "IR_SWAP"},
    "data.trade_date": {"gte": "2024-01-01", "lte": "2024-12-31"},
    "data.counterparty": {"regex": "^BANK.*"}
  }
}
```

### List Item Structure

List items are flexible JSON objects extracted from trades. The structure is determined by client needs and can include any subset of trade fields.

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system—essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*



### Core Properties

**Property 1: Save-Load Round Trip**
*For any* valid trade with a unique ID, saving it to the store and then loading it by ID should return an equivalent trade with all fields preserved.
**Validates: Requirements 1.1, 4.1**

**Property 2: Duplicate Prevention**
*For any* trade that already exists in the store (matching by ID), attempting to save it again via `/save/new` should fail with a 409 error.
**Validates: Requirements 1.2**

**Property 3: Full Update Replacement**
*For any* existing trade and any new trade data with the same ID, calling `/save/update` should completely replace the old trade data, and loading the trade should return the new data.
**Validates: Requirements 2.1**

**Property 4: Deep Merge Preservation**
*For any* existing trade and any partial update payload, calling `/save/partial` should:
- Preserve all fields not mentioned in the update
- Override fields that are mentioned in the update
- For nested objects set to null: remove the field if the existing value is an object, or set to null if the existing value is a primitive
- Recursively merge nested dictionaries
**Validates: Requirements 3.1, 3.3**

**Property 5: Delete Removes Trade**
*For any* existing trade, deleting it by ID should make it no longer retrievable via `/load/id`, which should return a 404 error.
**Validates: Requirements 9.1**

**Property 6: Delete Idempotency**
*For any* trade ID (existing or not), calling `/delete/id` should always return success (200), making delete operations idempotent.
**Validates: Requirements 9.2 (modified per design decision)**

### Bulk Operation Properties

**Property 7: Group Load Completeness**
*For any* list of trade IDs, calling `/load/group` should return exactly the trades that exist in the store and correctly identify all missing IDs in the response.
**Validates: Requirements 5.1, 5.2**

**Property 8: Group Delete Completeness**
*For any* list of trade IDs, calling `/delete/group` should remove all existing trades from the store and correctly report the count of deleted trades and missing IDs.
**Validates: Requirements 10.1, 10.2**

### Filter Properties

**Property 9: Filter Correctness**
*For any* filter criteria and any set of trades in the store, calling `/load/filter` should return all and only the trades that match the filter criteria according to the filter evaluation logic.
**Validates: Requirements 6.1**

**Property 10: Count Matches Filter**
*For any* filter criteria, the count returned by `/list/count` should equal the number of trades that would be returned by `/load/filter` with the same criteria.
**Validates: Requirements 8.1**

**Property 11: List Matches Filter**
*For any* filter criteria, the list items returned by `/list` should correspond exactly to the trades returned by `/load/filter` with the same criteria (same IDs, same count).
**Validates: Requirements 7.1**

### Filter Operator Properties

**Property 12: Equality Filter**
*For any* field path and value, a filter with `{"field": {"eq": value}}` should return all trades where the field equals the value and no trades where it doesn't.
**Validates: Requirements 6.1**

**Property 13: Range Filter**
*For any* field path and range bounds (min, max), a filter with `{"field": {"gte": min, "lte": max}}` should return all trades where the field value is within the range (inclusive) and no trades outside the range.
**Validates: Requirements 6.1**

**Property 14: Regex Filter**
*For any* field path and regex pattern, a filter with `{"field": {"regex": pattern}}` should return all trades where the field value matches the regex pattern and no trades that don't match.
**Validates: Requirements 6.1**

**Property 15: Multiple Filter Conditions (AND Logic)**
*For any* filter with multiple conditions, only trades that satisfy ALL conditions should be returned (AND logic).
**Validates: Requirements 6.1**

### Error Handling Properties

**Property 16: Not Found Errors**
*For any* operation that references a non-existent trade ID (update, partial update, load), the operation should fail with HTTP status 404 and an appropriate error message.
**Validates: Requirements 2.2, 3.2, 4.2**

**Property 17: Validation Errors**
*For any* request with invalid JSON structure or missing required fields, the operation should fail with HTTP status 422 and detailed error information.
**Validates: Requirements 1.3, 2.3, 6.3, 7.3, 8.3, 11.2**

**Property 18: Error Response Format**
*For any* error condition, the response should be valid JSON containing an error message and the appropriate HTTP status code.
**Validates: Requirements 13.1**

### Concurrency Property

**Property 19: Thread-Safe Operations**
*For any* sequence of concurrent save, load, update, and delete operations on different trades, all operations should complete successfully without data corruption or race conditions.
**Validates: Requirements 12.3**

### Context Metadata Property

**Property 20: Context Metadata Required for Mutating Operations**
*For any* save or delete API operation, the request must include valid context metadata with all required fields (user, agent, action, intent), or the operation should fail with HTTP status 422.
**Validates: Requirements 15.1, 15.2**

**Property 21: Context Metadata Logged**
*For any* mutating operation (save, update, delete), the context metadata should be stored in the operation log with a timestamp for lifecycle tracing.
**Validates: Requirements 15.3, 15.4**

**Property 22: Read Operations Do Not Require Context**
*For any* read operation (load, list, count), the operation should succeed without context metadata.
**Validates: Requirements 15.6**



## Error Handling

### Exception Hierarchy

```python
class TCSStoreException(Exception):
    """Base exception for TCS Store"""
    pass

class TradeNotFoundError(TCSStoreException):
    """Raised when a trade ID is not found"""
    pass

class TradeAlreadyExistsError(TCSStoreException):
    """Raised when attempting to create a trade that already exists"""
    pass

class InvalidFilterError(TCSStoreException):
    """Raised when a filter is malformed or invalid"""
    pass
```

### HTTP Status Code Mapping

- **200 OK**: Successful GET, PUT, DELETE operations
- **201 Created**: Successful POST to `/save/new`
- **404 Not Found**: Trade ID not found (load, update, partial update)
- **409 Conflict**: Trade already exists (save new)
- **422 Unprocessable Entity**: Validation errors (invalid JSON, missing required fields, invalid filter)
- **500 Internal Server Error**: Unexpected errors

### Error Response Format

All errors return JSON with this structure:
```json
{
  "error": "Brief error message",
  "detail": "Detailed explanation (optional)"
}
```

### Idempotency Behavior

- **DELETE operations**: Always return 200, even if the trade doesn't exist
- **UPDATE operations**: Return 404 if the trade doesn't exist (not idempotent)
- **SAVE operations**: Return 409 if the trade already exists (not idempotent)

This design preserves user intent - updates and saves require the expected state to exist, while deletes are safe to retry.

## Testing Strategy

### Overview

The TCS Store will be tested using a dual approach:
1. **Unit Tests**: Verify specific examples, edge cases, and error conditions
2. **Property-Based Tests**: Verify universal properties across all inputs

Both testing approaches are complementary and necessary for comprehensive coverage. Unit tests catch concrete bugs and validate specific scenarios, while property-based tests verify general correctness across a wide range of inputs.

### Property-Based Testing Framework

**Framework**: Hypothesis (Python)
- Industry-standard property-based testing library for Python
- Integrates seamlessly with pytest
- Supports complex data generation strategies
- Minimum 100 iterations per property test

### Test Organization

```
tests/
├── unit/
│   ├── test_save_operations.py
│   ├── test_load_operations.py
│   ├── test_delete_operations.py
│   ├── test_filter_operations.py
│   └── test_error_handling.py
├── property/
│   ├── test_save_load_properties.py
│   ├── test_update_properties.py
│   ├── test_filter_properties.py
│   ├── test_bulk_properties.py
│   └── test_concurrency_properties.py
└── integration/
    └── test_api_endpoints.py
```

### Property Test Configuration

Each property test must:
- Run minimum 100 iterations (configured via `@given` decorator settings)
- Include a comment tag referencing the design property
- Tag format: `# Feature: tcs-store, Property {number}: {property_text}`
- Use Hypothesis strategies to generate random test data

Example:
```python
from hypothesis import given, settings
import hypothesis.strategies as st

# Feature: tcs-store, Property 1: Save-Load Round Trip
@given(trade=st.fixed_dictionaries({"id": st.uuids().map(str), "data": st.dictionaries(st.text(), st.text())}))
@settings(max_examples=100)
def test_save_load_round_trip(trade):
    # Save trade
    response = client.post("/save/new", json={"trade": trade})
    assert response.status_code == 201
    
    # Load trade
    load_response = client.get(f"/load/id?id={trade['id']}")
    assert load_response.status_code == 200
    assert load_response.json() == trade
```

### Unit Test Focus Areas

Unit tests should focus on:
1. **Specific Examples**: Concrete scenarios that demonstrate correct behavior
2. **Edge Cases**: Empty lists, empty filters, null values, empty store
3. **Error Conditions**: Invalid JSON, missing IDs, malformed filters
4. **Integration Points**: API endpoint routing, request/response serialization
5. **Deep Merge Scenarios**: Specific nested object merge cases with null handling

### Property Test Focus Areas

Property tests should focus on:
1. **Round-trip properties**: Save then load, serialize then deserialize
2. **Invariants**: Properties that hold after operations (e.g., count after delete)
3. **Idempotence**: Operations that should have the same effect when repeated
4. **Metamorphic properties**: Relationships between operations (e.g., count matches filter length)
5. **Concurrency**: Thread-safe operations under concurrent access

### Test Data Generation Strategies

**Hypothesis Strategies**:
- **Trade IDs**: `st.uuids().map(str)` or `st.text(min_size=32, max_size=32)`
- **Trade Data**: `st.dictionaries(st.text(), st.json_values())`
- **Filters**: Custom strategy generating valid filter structures
- **Partial Updates**: Custom strategy generating nested dict updates with nulls

**Edge Cases to Include**:
- Empty store operations
- Single trade in store
- Large number of trades (1000+)
- Deeply nested trade data (5+ levels)
- Null values in various positions
- Empty strings, empty lists, empty dicts
- Unicode characters in string fields
- Very large numeric values

### Concurrency Testing

Use Hypothesis with threading to test concurrent operations:
```python
from hypothesis import given
from concurrent.futures import ThreadPoolExecutor

# Feature: tcs-store, Property 19: Thread-Safe Operations
@given(trades=st.lists(st.fixed_dictionaries(...), min_size=10, max_size=100))
@settings(max_examples=100)
def test_concurrent_operations(trades):
    with ThreadPoolExecutor(max_workers=10) as executor:
        # Submit concurrent save operations
        futures = [executor.submit(save_trade, trade) for trade in trades]
        results = [f.result() for f in futures]
    
    # Verify all trades were saved correctly
    for trade in trades:
        loaded = load_trade(trade['id'])
        assert loaded == trade
```

### Integration Testing

Integration tests verify end-to-end API behavior:
- FastAPI TestClient for HTTP requests
- Test all endpoints with realistic payloads
- Verify HTTP status codes and response formats
- Test error scenarios and edge cases

### Test Coverage Goals

- **Line Coverage**: Minimum 90%
- **Branch Coverage**: Minimum 85%
- **Property Coverage**: All 19 properties implemented as property tests
- **Endpoint Coverage**: 100% of API endpoints tested

### Continuous Testing

- Run unit tests on every commit
- Run property tests on every pull request
- Run integration tests before deployment
- Monitor test execution time (property tests may be slower)

